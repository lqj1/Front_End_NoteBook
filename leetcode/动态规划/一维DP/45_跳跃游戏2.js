/**
 * @param {number[]} nums
 * @return {number}
 */
/**
思路:
1. 如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。
  11. 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。
  12. 因为会把各个起跳点都试一遍，所以不会存在漏掉先长跳后短跳或相反的情况
2. 如果从这个 起跳点 起跳叫做第 1 次 跳跃，那么从后面 3 个格子起跳 都 可以叫做第 2 次 跳跃。
3. 所以，当一次 跳跃 结束时，从下一个格子开始，到现在 能跳到最远的距离，都 是下一次 跳跃 的 起跳点。
  31. 对每一次 跳跃 用 for 循环来模拟。
  32. 跳完一次之后，更新下一次 起跳点 的范围。
  33. 在新的范围内跳，更新 能跳到最远的距离。
4. 记录 跳跃 次数，如果跳到了终点，就得到了结果。

 */
var jump = function(nums) {
  let res = 0
  let maxPos = 0
  let end = 0
  for (let i = 0; i < nums.length - 1; i++) {
    maxPos = Math.max(maxPos, i + nums[i])
    if (i == end) {
      end = maxPos
      res += 1
    }
  }
  return res
};